// ============================================================
// AUTHENTICATION SYSTEM - PASSKEYS + JWT
// Zero-password authentication with WebAuthn
// ============================================================

import express from 'express';
import { 
  generateRegistrationOptions, 
  verifyRegistrationResponse,
  generateAuthenticationOptions,
  verifyAuthenticationResponse 
} from '@simplewebauthn/server';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { PrismaClient } from '@prisma/client';
import { customAlphabet } from 'nanoid';

const router = express.Router();
const prisma = new PrismaClient();
const nanoid = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 21);

// Configuration WebAuthn
const RP_NAME = 'Cloud Nexus 2030';
const RP_ID = process.env.RP_ID || 'localhost';
const ORIGIN = process.env.ORIGIN || 'http://localhost:3000';
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';
const JWT_EXPIRES_IN = '7d';

// ============================================================
// HELPER FUNCTIONS
// ============================================================

/**
 * Génère un token JWT
 */
function generateToken(userId, email, role) {
  return jwt.sign(
    { 
      userId, 
      email, 
      role,
      iat: Math.floor(Date.now() / 1000)
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
}

/**
 * Génère un refresh token
 */
function generateRefreshToken(userId) {
  return jwt.sign(
    { userId, type: 'refresh' },
    JWT_SECRET,
    { expiresIn: '30d' }
  );
}

/**
 * Vérifie un token JWT
 */
function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}

/**
 * Middleware d'authentification
 */
export function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'No token provided' });
  }

  const token = authHeader.substring(7);
  const decoded = verifyToken(token);

  if (!decoded) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }

  req.user = decoded;
  next();
}

/**
 * Middleware de vérification de rôle
 */
export function requireRole(...roles) {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
}

// ============================================================
// PASSKEYS REGISTRATION (WebAuthn)
// ============================================================

/**
 * POST /auth/passkey/register/options
 * Génère les options pour l'enregistrement d'une passkey
 */
router.post('/passkey/register/options', async (req, res) => {
  try {
    const { email, name } = req.body;

    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    // Vérifier si l'utilisateur existe déjà
    let user = await prisma.user.findUnique({ where: { email } });

    if (!user) {
      // Créer un nouvel utilisateur
      user = await prisma.user.create({
        data: {
          id: nanoid(),
          email,
          name: name || email.split('@')[0],
          role: 'CLIENT'
        }
      });
    }

    // Récupérer les credentials existants
    const userCredentials = await prisma.credential.findMany({
      where: { userId: user.id }
    });

    const options = await generateRegistrationOptions({
      rpName: RP_NAME,
      rpID: RP_ID,
      userID: user.id,
      userName: email,
      userDisplayName: user.name,
      timeout: 60000,
      attestationType: 'none',
      excludeCredentials: userCredentials.map(cred => ({
        id: Buffer.from(cred.credentialID, 'base64'),
        type: 'public-key',
        transports: cred.transports || []
      })),
      authenticatorSelection: {
        authenticatorAttachment: 'platform',
        requireResidentKey: true,
        residentKey: 'required',
        userVerification: 'required'
      },
      supportedAlgorithmIDs: [-7, -257]
    });

    // Stocker le challenge temporairement (Redis en production)
    await prisma.challengeStore.upsert({
      where: { userId: user.id },
      update: { 
        challenge: options.challenge,
        expiresAt: new Date(Date.now() + 300000) // 5 minutes
      },
      create: {
        userId: user.id,
        challenge: options.challenge,
        expiresAt: new Date(Date.now() + 300000)
      }
    });

    res.json({
      success: true,
      options,
      userId: user.id
    });

  } catch (error) {
    console.error('Passkey registration options error:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /auth/passkey/register/verify
 * Vérifie l'enregistrement de la passkey
 */
router.post('/passkey/register/verify', async (req, res) => {
  try {
    const { userId, credential } = req.body;

    const user = await prisma.user.findUnique({ where: { id: userId } });
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Récupérer le challenge
    const challengeData = await prisma.challengeStore.findUnique({
      where: { userId }
    });

    if (!challengeData || new Date() > challengeData.expiresAt) {
      return res.status(400).json({ error: 'Challenge expired or not found' });
    }

    const verification = await verifyRegistrationResponse({
      response: credential,
      expectedChallenge: challengeData.challenge,
      expectedOrigin: ORIGIN,
      expectedRPID: RP_ID
    });

    if (!verification.verified) {
      return res.status(400).json({ error: 'Verification failed' });
    }

    const { credentialPublicKey, credentialID, counter } = verification.registrationInfo;

    // Sauvegarder la credential
    await prisma.credential.create({
      data: {
        userId,
        credentialID: Buffer.from(credentialID).toString('base64'),
        publicKey: Buffer.from(credentialPublicKey).toString('base64'),
        counter,
        transports: credential.response.transports || []
      }
    });

    // Nettoyer le challenge
    await prisma.challengeStore.delete({ where: { userId } });

    // Générer les tokens
    const accessToken = generateToken(user.id, user.email, user.role);
    const refreshToken = generateRefreshToken(user.id);

    // Sauvegarder le refresh token
    await prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: user.id,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 jours
      }
    });

    res.json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Passkey registration verify error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================
// PASSKEYS AUTHENTICATION
// ============================================================

/**
 * POST /auth/passkey/login/options
 * Génère les options pour la connexion
 */
router.post('/passkey/login/options', async (req, res) => {
  try {
    const { email } = req.body;

    const user = await prisma.user.findUnique({ 
      where: { email },
      include: { credentials: true }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const options = await generateAuthenticationOptions({
      rpID: RP_ID,
      timeout: 60000,
      allowCredentials: user.credentials.map(cred => ({
        id: Buffer.from(cred.credentialID, 'base64'),
        type: 'public-key',
        transports: cred.transports || []
      })),
      userVerification: 'required'
    });

    // Stocker le challenge
    await prisma.challengeStore.upsert({
      where: { userId: user.id },
      update: { 
        challenge: options.challenge,
        expiresAt: new Date(Date.now() + 300000)
      },
      create: {
        userId: user.id,
        challenge: options.challenge,
        expiresAt: new Date(Date.now() + 300000)
      }
    });

    res.json({
      success: true,
      options,
      userId: user.id
    });

  } catch (error) {
    console.error('Passkey login options error:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /auth/passkey/login/verify
 * Vérifie l'authentification
 */
router.post('/passkey/login/verify', async (req, res) => {
  try {
    const { userId, credential } = req.body;

    const user = await prisma.user.findUnique({ 
      where: { id: userId },
      include: { credentials: true }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const challengeData = await prisma.challengeStore.findUnique({
      where: { userId }
    });

    if (!challengeData || new Date() > challengeData.expiresAt) {
      return res.status(400).json({ error: 'Challenge expired' });
    }

    // Trouver la credential correspondante
    const dbCredential = user.credentials.find(
      cred => cred.credentialID === Buffer.from(credential.id).toString('base64')
    );

    if (!dbCredential) {
      return res.status(404).json({ error: 'Credential not found' });
    }

    const verification = await verifyAuthenticationResponse({
      response: credential,
      expectedChallenge: challengeData.challenge,
      expectedOrigin: ORIGIN,
      expectedRPID: RP_ID,
      authenticator: {
        credentialID: Buffer.from(dbCredential.credentialID, 'base64'),
        credentialPublicKey: Buffer.from(dbCredential.publicKey, 'base64'),
        counter: dbCredential.counter
      }
    });

    if (!verification.verified) {
      return res.status(400).json({ error: 'Authentication failed' });
    }

    // Mettre à jour le counter
    await prisma.credential.update({
      where: { id: dbCredential.id },
      data: { 
        counter: verification.authenticationInfo.newCounter,
        lastUsed: new Date()
      }
    });

    // Nettoyer le challenge
    await prisma.challengeStore.delete({ where: { userId } });

    // Générer les tokens
    const accessToken = generateToken(user.id, user.email, user.role);
    const refreshToken = generateRefreshToken(user.id);

    await prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: user.id,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      }
    });

    res.json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Passkey login verify error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================
// TRADITIONAL EMAIL/PASSWORD (Fallback)
// ============================================================

/**
 * POST /auth/register
 * Inscription classique avec email/password
 */
router.post('/register', async (req, res) => {
  try {
    const { email, password, name } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    // Vérifier si l'utilisateur existe
    const existing = await prisma.user.findUnique({ where: { email } });
    
    if (existing) {
      return res.status(409).json({ error: 'User already exists' });
    }

    // Hasher le mot de passe
    const hashedPassword = await bcrypt.hash(password, 12);

    // Créer l'utilisateur
    const user = await prisma.user.create({
      data: {
        id: nanoid(),
        email,
        password: hashedPassword,
        name: name || email.split('@')[0],
        role: 'CLIENT'
      }
    });

    const accessToken = generateToken(user.id, user.email, user.role);
    const refreshToken = generateRefreshToken(user.id);

    await prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: user.id,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      }
    });

    res.status(201).json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /auth/login
 * Connexion classique
 */
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await prisma.user.findUnique({ where: { email } });

    if (!user || !user.password) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const valid = await bcrypt.compare(password, user.password);

    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const accessToken = generateToken(user.id, user.email, user.role);
    const refreshToken = generateRefreshToken(user.id);

    await prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: user.id,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
      }
    });

    res.json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================
// TOKEN MANAGEMENT
// ============================================================

/**
 * POST /auth/refresh
 * Rafraîchissement du token
 */
router.post('/refresh', async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({ error: 'Refresh token required' });
    }

    const decoded = verifyToken(refreshToken);

    if (!decoded || decoded.type !== 'refresh') {
      return res.status(401).json({ error: 'Invalid refresh token' });
    }

    // Vérifier en DB
    const tokenRecord = await prisma.refreshToken.findFirst({
      where: { 
        token: refreshToken,
        userId: decoded.userId,
        expiresAt: { gte: new Date() }
      },
      include: { user: true }
    });

    if (!tokenRecord) {
      return res.status(401).json({ error: 'Refresh token expired or invalid' });
    }

    const newAccessToken = generateToken(
      tokenRecord.user.id, 
      tokenRecord.user.email, 
      tokenRecord.user.role
    );

    res.json({
      success: true,
      accessToken: newAccessToken
    });

  } catch (error) {
    console.error('Refresh error:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * POST /auth/logout
 * Déconnexion (invalide le refresh token)
 */
router.post('/logout', authMiddleware, async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (refreshToken) {
      await prisma.refreshToken.deleteMany({
        where: { 
          token: refreshToken,
          userId: req.user.userId
        }
      });
    }

    res.json({ success: true, message: 'Logged out successfully' });

  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * GET /auth/me
 * Récupère les infos de l'utilisateur connecté
 */
router.get('/me', authMiddleware, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.user.userId },
      select: {
        id: true,
        email: true,
        name: true,
        avatar: true,
        role: true,
        createdAt: true
      }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ success: true, user });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

export default router;