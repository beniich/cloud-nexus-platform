// ============================================================
// COMPLETE TEST SUITE - Cloud Nexus 2030 Backend
// Jest + Supertest + Prisma Mock
// ============================================================

import { describe, test, expect, beforeAll, afterAll, beforeEach, jest } from '@jest/globals';
import request from 'supertest';
import express from 'express';
import { PrismaClient } from '@prisma/client';
import jwt from 'jsonwebtoken';

// ============================================================
// TEST CONFIGURATION
// ============================================================

const app = express();
app.use(express.json());

const prisma = new PrismaClient({
  datasources: {
    db: { url: process.env.DATABASE_URL_TEST }
  }
});

const JWT_SECRET = 'test-secret-key';

// Mock services
jest.mock('@anthropic-ai/sdk');
jest.mock('openai');

// ============================================================
// HELPER FUNCTIONS
// ============================================================

function generateTestToken(userId = 'test-user-id') {
  return jwt.sign(
    { userId, email: 'test@example.com', role: 'CLIENT' },
    JWT_SECRET,
    { expiresIn: '1h' }
  );
}

async function createTestUser() {
  return await prisma.user.create({
    data: {
      id: 'test-user-id',
      email: 'test@example.com',
      name: 'Test User',
      role: 'CLIENT'
    }
  });
}

async function createTestSite(userId) {
  return await prisma.site.create({
    data: {
      id: 'test-site-id',
      name: 'Test Site',
      content: {
        metadata: { title: 'Test Site' },
        sections: []
      },
      userId,
      published: false
    }
  });
}

// ============================================================
// 1. AUTHENTICATION TESTS
// ============================================================

describe('Authentication System', () => {
  
  beforeAll(async () => {
    await prisma.$connect();
  });

  afterAll(async () => {
    await prisma.user.deleteMany();
    await prisma.$disconnect();
  });

  describe('POST /auth/register', () => {
    
    test('should register a new user successfully', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send({
          email: 'newuser@example.com',
          password: 'SecurePass123!',
          name: 'New User'
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body).toHaveProperty('accessToken');
      expect(response.body).toHaveProperty('refreshToken');
      expect(response.body.user.email).toBe('newuser@example.com');
    });

    test('should reject duplicate email', async () => {
      await request(app)
        .post('/auth/register')
        .send({
          email: 'duplicate@example.com',
          password: 'Pass123!'
        });

      const response = await request(app)
        .post('/auth/register')
        .send({
          email: 'duplicate@example.com',
          password: 'Pass123!'
        });

      expect(response.status).toBe(409);
      expect(response.body.error).toContain('already exists');
    });

    test('should validate password requirements', async () => {
      const response = await request(app)
        .post('/auth/register')
        .send({
          email: 'weak@example.com',
          password: '123'
        });

      expect(response.status).toBe(400);
      expect(response.body.error).toBeDefined();
    });
  });

  describe('POST /auth/login', () => {
    
    beforeEach(async () => {
      await createTestUser();
    });

    test('should login with valid credentials', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'test@example.com',
          password: 'TestPassword123!'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body).toHaveProperty('accessToken');
    });

    test('should reject invalid credentials', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'test@example.com',
          password: 'WrongPassword'
        });

      expect(response.status).toBe(401);
      expect(response.body.error).toContain('Invalid credentials');
    });

    test('should reject non-existent user', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'nonexistent@example.com',
          password: 'Password123!'
        });

      expect(response.status).toBe(401);
    });
  });

  describe('POST /auth/refresh', () => {
    
    test('should refresh access token with valid refresh token', async () => {
      const user = await createTestUser();
      const refreshToken = jwt.sign(
        { userId: user.id, type: 'refresh' },
        JWT_SECRET,
        { expiresIn: '30d' }
      );

      await prisma.refreshToken.create({
        data: {
          token: refreshToken,
          userId: user.id,
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        }
      });

      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('accessToken');
    });

    test('should reject expired refresh token', async () => {
      const expiredToken = jwt.sign(
        { userId: 'test-id', type: 'refresh' },
        JWT_SECRET,
        { expiresIn: '-1h' }
      );

      const response = await request(app)
        .post('/auth/refresh')
        .send({ refreshToken: expiredToken });

      expect(response.status).toBe(401);
    });
  });

  describe('GET /auth/me', () => {
    
    test('should return user info with valid token', async () => {
      const user = await createTestUser();
      const token = generateTestToken(user.id);

      const response = await request(app)
        .get('/auth/me')
        .set('Authorization', `Bearer ${token}`);

      expect(response.status).toBe(200);
      expect(response.body.user.email).toBe(user.email);
    });

    test('should reject request without token', async () => {
      const response = await request(app)
        .get('/auth/me');

      expect(response.status).toBe(401);
    });
  });
});

// ============================================================
// 2. VOICE BUILDER TESTS
// ============================================================

describe('Voice Builder Service', () => {
  
  let testUser;
  let authToken;

  beforeAll(async () => {
    testUser = await createTestUser();
    authToken = generateTestToken(testUser.id);
  });

  describe('POST /api/voice/upload', () => {
    
    test('should transcribe audio file', async () => {
      // Mock Whisper API response
      const mockTranscription = 'Create a modern restaurant website';
      
      const response = await request(app)
        .post('/api/voice/upload')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('audio', Buffer.from('fake-audio-data'), 'test.webm')
        .field('userId', testUser.id);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.transcription).toBeDefined();
    });

    test('should reject non-audio files', async () => {
      const response = await request(app)
        .post('/api/voice/upload')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('audio', Buffer.from('not-audio'), 'test.txt');

      expect(response.status).toBe(400);
    });
  });

  describe('POST /api/voice/generate', () => {
    
    test('should generate complete site from transcript', async () => {
      const transcript = 'Create a Japanese restaurant site with dark theme and reservation system';

      const response = await request(app)
        .post('/api/voice/generate')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          transcript,
          userId: testUser.id
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.site).toHaveProperty('metadata');
      expect(response.body.site).toHaveProperty('sections');
      expect(response.body.site.metadata.title).toBeDefined();
    });

    test('should handle invalid transcript', async () => {
      const response = await request(app)
        .post('/api/voice/generate')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          transcript: '',
          userId: testUser.id
        });

      expect(response.status).toBe(400);
    });

    test('should save generated site to database', async () => {
      const transcript = 'Build a portfolio site';

      const response = await request(app)
        .post('/api/voice/generate')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ transcript, userId: testUser.id });

      const site = await prisma.site.findUnique({
        where: { id: response.body.siteId }
      });

      expect(site).toBeDefined();
      expect(site.userId).toBe(testUser.id);
    });
  });

  describe('GET /api/voice/site/:id', () => {
    
    test('should retrieve generated site', async () => {
      const site = await createTestSite(testUser.id);

      const response = await request(app)
        .get(`/api/voice/site/${site.id}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.site.id).toBe(site.id);
    });

    test('should return 404 for non-existent site', async () => {
      const response = await request(app)
        .get('/api/voice/site/non-existent-id')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(404);
    });
  });
});

// ============================================================
// 3. DEPLOYMENT TESTS
// ============================================================

describe('Deployment Service', () => {
  
  let testUser;
  let testSite;
  let authToken;

  beforeAll(async () => {
    testUser = await createTestUser();
    testSite = await createTestSite(testUser.id);
    authToken = generateTestToken(testUser.id);
  });

  describe('POST /deploy/site/:siteId', () => {
    
    test('should deploy site to Vercel', async () => {
      // Mock Vercel API
      const mockVercelResponse = {
        url: 'test-site.vercel.app',
        id: 'deployment-id-123'
      };

      const response = await request(app)
        .post(`/deploy/site/${testSite.id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          provider: 'vercel'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.url).toBeDefined();
    });

    test('should deploy site to Netlify', async () => {
      const response = await request(app)
        .post(`/deploy/site/${testSite.id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          provider: 'netlify'
        });

      expect(response.status).toBe(200);
      expect(response.body.provider).toBe('netlify');
    });

    test('should handle deployment failures', async () => {
      // Mock API error
      const response = await request(app)
        .post('/deploy/site/invalid-site-id')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          provider: 'vercel'
        });

      expect(response.status).toBe(500);
    });

    test('should save deployment record to database', async () => {
      const response = await request(app)
        .post(`/deploy/site/${testSite.id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ provider: 'vercel' });

      const deployment = await prisma.deployment.findFirst({
        where: { siteId: testSite.id }
      });

      expect(deployment).toBeDefined();
      expect(deployment.provider).toBe('vercel');
      expect(deployment.status).toBe('DEPLOYED');
    });
  });

  describe('GET /deploy/site/:siteId/deployments', () => {
    
    test('should list all deployments for a site', async () => {
      await prisma.deployment.create({
        data: {
          siteId: testSite.id,
          provider: 'vercel',
          url: 'test.vercel.app',
          deploymentId: 'dep-123',
          status: 'DEPLOYED'
        }
      });

      const response = await request(app)
        .get(`/deploy/site/${testSite.id}/deployments`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.deployments).toBeInstanceOf(Array);
      expect(response.body.deployments.length).toBeGreaterThan(0);
    });
  });

  describe('DELETE /deploy/:deploymentId', () => {
    
    test('should destroy a deployment', async () => {
      const deployment = await prisma.deployment.create({
        data: {
          siteId: testSite.id,
          provider: 'vercel',
          url: 'test.vercel.app',
          deploymentId: 'dep-456',
          status: 'DEPLOYED'
        }
      });

      const response = await request(app)
        .delete(`/deploy/${deployment.id}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);

      const destroyed = await prisma.deployment.findUnique({
        where: { id: deployment.id }
      });

      expect(destroyed.status).toBe('DESTROYED');
    });
  });
});

// ============================================================
// 4. INTEGRATION TESTS
// ============================================================

describe('End-to-End Workflow', () => {
  
  test('Complete user journey: Register → Voice Build → Deploy', async () => {
    // 1. Register user
    const registerRes = await request(app)
      .post('/auth/register')
      .send({
        email: 'journey@example.com',
        password: 'SecurePass123!',
        name: 'Journey User'
      });

    expect(registerRes.status).toBe(201);
    const { accessToken } = registerRes.body;

    // 2. Generate site via voice
    const generateRes = await request(app)
      .post('/api/voice/generate')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({
        transcript: 'Create a portfolio website for a photographer',
        userId: registerRes.body.user.id
      });

    expect(generateRes.status).toBe(200);
    const { siteId } = generateRes.body;

    // 3. Deploy site
    const deployRes = await request(app)
      .post(`/deploy/site/${siteId}`)
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ provider: 'vercel' });

    expect(deployRes.status).toBe(200);
    expect(deployRes.body.url).toContain('vercel.app');

    // 4. Verify site is published
    const siteRes = await request(app)
      .get(`/api/voice/site/${siteId}`)
      .set('Authorization', `Bearer ${accessToken}`);

    expect(siteRes.body.site.published).toBe(true);
  });
});

// ============================================================
// 5. PERFORMANCE TESTS
// ============================================================

describe('Performance & Load Tests', () => {
  
  test('should handle concurrent site generations', async () => {
    const user = await createTestUser();
    const token = generateTestToken(user.id);

    const promises = Array(10).fill(null).map((_, i) => 
      request(app)
        .post('/api/voice/generate')
        .set('Authorization', `Bearer ${token}`)
        .send({
          transcript: `Create site ${i}`,
          userId: user.id
        })
    );

    const results = await Promise.all(promises);

    results.forEach(res => {
      expect(res.status).toBe(200);
    });
  });

  test('should complete generation in under 10 seconds', async () => {
    const user = await createTestUser();
    const token = generateTestToken(user.id);

    const startTime = Date.now();

    await request(app)
      .post('/api/voice/generate')
      .set('Authorization', `Bearer ${token}`)
      .send({
        transcript: 'Create a blog',
        userId: user.id
      });

    const duration = Date.now() - startTime;

    expect(duration).toBeLessThan(10000); // 10 seconds
  });
});

// ============================================================
// 6. SECURITY TESTS
// ============================================================

describe('Security & Authorization', () => {
  
  test('should prevent unauthorized access to protected routes', async () => {
    const response = await request(app)
      .get('/api/voice/site/test-id');

    expect(response.status).toBe(401);
  });

  test('should prevent accessing other users\' sites', async () => {
    const user1 = await createTestUser();
    const user2 = await prisma.user.create({
      data: {
        id: 'user2-id',
        email: 'user2@example.com',
        name: 'User 2',
        role: 'CLIENT'
      }
    });

    const site = await createTestSite(user1.id);
    const token2 = generateTestToken(user2.id);

    const response = await request(app)
      .get(`/api/voice/site/${site.id}`)
      .set('Authorization', `Bearer ${token2}`);

    expect(response.status).toBe(403);
  });

  test('should sanitize user input', async () => {
    const user = await createTestUser();
    const token = generateTestToken(user.id);

    const maliciousInput = '<script>alert("XSS")</script>';

    const response = await request(app)
      .post('/api/voice/generate')
      .set('Authorization', `Bearer ${token}`)
      .send({
        transcript: maliciousInput,
        userId: user.id
      });

    expect(response.body.site.metadata.title).not.toContain('<script>');
  });
});

// ============================================================
// TEST UTILITIES
// ============================================================

// Run before all tests
beforeAll(async () => {
  process.env.JWT_SECRET = JWT_SECRET;
  process.env.NODE_ENV = 'test';
});

// Cleanup after all tests
afterAll(async () => {
  await prisma.user.deleteMany();
  await prisma.site.deleteMany();
  await prisma.deployment.deleteMany();
  await prisma.$disconnect();
});