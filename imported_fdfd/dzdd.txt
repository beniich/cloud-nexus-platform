// ============================================================
// VOICE BUILDER SERVICE - COMPLETE BACKEND
// Whisper (Speech-to-Text) + Claude (Site Generation)
// ============================================================

import express from 'express';
import multer from 'multer';
import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';
import { PrismaClient } from '@prisma/client';
import cors from 'cors';
import fs from 'fs/promises';
import path from 'path';

const app = express();
const prisma = new PrismaClient();
const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ============================================================
// MIDDLEWARE
// ============================================================

app.use(cors({
  origin: process.env.CLIENT_URL,
  credentials: true
}));

app.use(express.json({ limit: '50mb' }));

// Configuration Multer pour upload audio
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = './uploads/audio';
    await fs.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 25 * 1024 * 1024 }, // 25MB max
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['audio/webm', 'audio/mp3', 'audio/wav', 'audio/mpeg', 'audio/ogg'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid audio format'));
    }
  }
});

// ============================================================
// VOICE BUILDER SERVICE CLASS
// ============================================================

class VoiceBuilderService {
  
  /**
   * Transcription audio vers texte avec Whisper
   */
  async transcribeAudio(audioFilePath) {
    try {
      console.log('ðŸŽ™ï¸ Starting transcription with Whisper...');
      
      const audioFile = await fs.readFile(audioFilePath);
      
      const transcription = await openai.audio.transcriptions.create({
        file: new File([audioFile], path.basename(audioFilePath)),
        model: 'whisper-1',
        language: 'en', // ou 'fr' pour franÃ§ais
        response_format: 'verbose_json',
        timestamp_granularities: ['word']
      });

      console.log('âœ… Transcription completed');
      
      return {
        text: transcription.text,
        duration: transcription.duration,
        words: transcription.words,
        language: transcription.language
      };
      
    } catch (error) {
      console.error('âŒ Whisper API error:', error);
      throw new Error(`Transcription failed: ${error.message}`);
    }
  }

  /**
   * Analyse de l'intention avec Claude
   */
  async analyzeIntent(transcript) {
    try {
      console.log('ðŸ§  Analyzing user intent with Claude...');
      
      const message = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1500,
        system: `Tu es un expert en analyse d'intentions utilisateur pour la crÃ©ation de sites web.
        
Ã€ partir d'une transcription vocale, extrait:
1. Type de site (e-commerce, portfolio, blog, SaaS, restaurant, etc.)
2. FonctionnalitÃ©s demandÃ©es
3. Style visuel souhaitÃ©
4. Public cible
5. Contraintes techniques mentionnÃ©es

RÃ©ponds UNIQUEMENT en JSON valide avec cette structure:
{
  "websiteType": "type de site",
  "features": ["feature1", "feature2"],
  "visualStyle": {
    "theme": "light/dark/custom",
    "colors": ["primary", "secondary"],
    "vibe": "minimal/modern/playful/professional"
  },
  "targetAudience": "description",
  "technicalRequirements": ["req1", "req2"],
  "confidence": 0.0-1.0
}`,
        messages: [{
          role: 'user',
          content: transcript
        }]
      });

      const intentAnalysis = JSON.parse(message.content[0].text);
      console.log('âœ… Intent analysis completed');
      
      return intentAnalysis;
      
    } catch (error) {
      console.error('âŒ Claude intent analysis error:', error);
      throw new Error(`Intent analysis failed: ${error.message}`);
    }
  }

  /**
   * GÃ©nÃ©ration de la structure complÃ¨te du site
   */
  async generateSiteStructure(intentAnalysis, transcript) {
    try {
      console.log('ðŸ—ï¸ Generating site structure with Claude...');
      
      const message = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 8000,
        temperature: 0.7,
        system: `Tu es un expert UI/UX designer et dÃ©veloppeur web.

GÃ©nÃ¨re une structure complÃ¨te de site web en JSON basÃ©e sur l'analyse d'intention.

IMPORTANT: RÃ©ponds UNIQUEMENT avec un JSON valide, sans markdown, sans commentaires.

Structure attendue:
{
  "metadata": {
    "title": "titre du site",
    "description": "meta description SEO",
    "keywords": ["keyword1", "keyword2"],
    "favicon": "emoji ou URL"
  },
  "theme": {
    "colors": {
      "primary": "#hex",
      "secondary": "#hex",
      "background": "#hex",
      "text": "#hex"
    },
    "fonts": {
      "heading": "font-family",
      "body": "font-family"
    },
    "spacing": "tight/normal/relaxed",
    "borderRadius": "none/sm/md/lg/full"
  },
  "sections": [
    {
      "type": "hero",
      "layout": "centered/split/fullscreen",
      "content": {
        "headline": "texte principal",
        "subheadline": "texte secondaire",
        "cta": {
          "text": "texte bouton",
          "action": "scroll/link/modal",
          "style": "primary/secondary"
        },
        "background": {
          "type": "gradient/image/video",
          "value": "dÃ©tails"
        }
      }
    },
    {
      "type": "features",
      "layout": "grid/list/carousel",
      "items": [
        {
          "icon": "emoji ou icon-name",
          "title": "titre feature",
          "description": "description"
        }
      ]
    }
  ],
  "components": {
    "navbar": {
      "style": "fixed/sticky/static",
      "logo": "text/image",
      "links": ["Home", "About", "Contact"]
    },
    "footer": {
      "columns": [
        {
          "title": "Section",
          "links": ["Link1", "Link2"]
        }
      ],
      "copyright": "texte"
    }
  },
  "analytics": {
    "performanceScore": 0.0-1.0,
    "seoScore": 0.0-1.0,
    "accessibilityScore": 0.0-1.0
  }
}`,
        messages: [{
          role: 'user',
          content: `Transcription originale: "${transcript}"

Analyse d'intention:
${JSON.stringify(intentAnalysis, null, 2)}

GÃ©nÃ¨re maintenant la structure complÃ¨te du site.`
        }]
      });

      // Extraction et nettoyage du JSON
      let siteStructure = message.content[0].text.trim();
      
      // Retirer les backticks markdown si prÃ©sents
      siteStructure = siteStructure.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
      
      const parsedStructure = JSON.parse(siteStructure);
      
      console.log('âœ… Site structure generated');
      
      return parsedStructure;
      
    } catch (error) {
      console.error('âŒ Site generation error:', error);
      throw new Error(`Site generation failed: ${error.message}`);
    }
  }

  /**
   * Optimisation SEO et Performance
   */
  async optimizeSite(siteStructure) {
    try {
      console.log('âš¡ Optimizing site for SEO and performance...');
      
      const message = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 2000,
        system: `Tu es un expert SEO et performance web.

Analyse la structure du site et propose des optimisations.

RÃ©ponds en JSON:
{
  "seo": {
    "improvements": ["amÃ©lioration1", "amÃ©lioration2"],
    "metaTags": {
      "og:title": "valeur",
      "og:description": "valeur",
      "twitter:card": "valeur"
    }
  },
  "performance": {
    "lazyLoadImages": true/false,
    "criticalCSS": "inline critical styles",
    "preloadAssets": ["asset1", "asset2"],
    "compressionRecommendations": ["webp", "minify-js"]
  },
  "accessibility": {
    "ariaLabels": {"element": "label"},
    "colorContrast": "AAA/AA/fail",
    "recommendations": ["rec1", "rec2"]
  }
}`,
        messages: [{
          role: 'user',
          content: JSON.stringify(siteStructure, null, 2)
        }]
      });

      let optimizations = message.content[0].text.trim();
      optimizations = optimizations.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
      
      const parsedOptimizations = JSON.parse(optimizations);
      
      console.log('âœ… Optimizations completed');
      
      return parsedOptimizations;
      
    } catch (error) {
      console.error('âŒ Optimization error:', error);
      return null; // Non-bloquant
    }
  }

  /**
   * Sauvegarde en base de donnÃ©es
   */
  async saveSiteToDatabase(userId, siteData) {
    try {
      const site = await prisma.site.create({
        data: {
          name: siteData.metadata.title,
          content: siteData,
          userId: userId,
          published: false,
          metadata: {
            generatedVia: 'voice',
            transcriptLength: siteData._transcript?.length || 0,
            confidenceScore: siteData._intentAnalysis?.confidence || 0
          }
        }
      });

      console.log('ðŸ’¾ Site saved to database:', site.id);
      
      return site;
    } catch (error) {
      console.error('âŒ Database save error:', error);
      throw error;
    }
  }
}

// ============================================================
// API ROUTES
// ============================================================

const voiceBuilder = new VoiceBuilderService();

/**
 * POST /api/voice/upload
 * Upload et transcription d'un fichier audio
 */
app.post('/api/voice/upload', upload.single('audio'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No audio file provided' });
    }

    const userId = req.body.userId || 'anonymous';
    const audioPath = req.file.path;

    // 1. Transcription
    const transcription = await voiceBuilder.transcribeAudio(audioPath);

    // Nettoyage du fichier temporaire
    await fs.unlink(audioPath);

    res.json({
      success: true,
      transcription: transcription.text,
      metadata: {
        duration: transcription.duration,
        language: transcription.language,
        wordCount: transcription.words?.length || 0
      }
    });

  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ 
      error: error.message,
      details: 'Transcription failed'
    });
  }
});

/**
 * POST /api/voice/generate
 * GÃ©nÃ©ration complÃ¨te du site depuis une transcription
 */
app.post('/api/voice/generate', async (req, res) => {
  try {
    const { transcript, userId } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'Transcript is required' });
    }

    console.log(`\nðŸš€ Starting site generation for user: ${userId}`);
    console.log(`ðŸ“ Transcript: "${transcript.substring(0, 100)}..."`);

    // 1. Analyse d'intention
    const intentAnalysis = await voiceBuilder.analyzeIntent(transcript);

    // 2. GÃ©nÃ©ration de la structure
    const siteStructure = await voiceBuilder.generateSiteStructure(
      intentAnalysis, 
      transcript
    );

    // 3. Optimisation
    const optimizations = await voiceBuilder.optimizeSite(siteStructure);

    // 4. Fusion des donnÃ©es
    const completeSite = {
      ...siteStructure,
      optimizations,
      _metadata: {
        generatedAt: new Date().toISOString(),
        generatedVia: 'voice',
        processingTime: Date.now() // Ã€ calculer correctement
      },
      _transcript: transcript,
      _intentAnalysis: intentAnalysis
    };

    // 5. Sauvegarde en DB
    const savedSite = await voiceBuilder.saveSiteToDatabase(userId, completeSite);

    res.json({
      success: true,
      siteId: savedSite.id,
      site: completeSite,
      preview: {
        title: completeSite.metadata.title,
        sectionsCount: completeSite.sections.length,
        theme: completeSite.theme.colors.primary
      }
    });

  } catch (error) {
    console.error('âŒ Generation error:', error);
    res.status(500).json({ 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

/**
 * GET /api/voice/site/:id
 * RÃ©cupÃ©ration d'un site gÃ©nÃ©rÃ©
 */
app.get('/api/voice/site/:id', async (req, res) => {
  try {
    const site = await prisma.site.findUnique({
      where: { id: req.params.id }
    });

    if (!site) {
      return res.status(404).json({ error: 'Site not found' });
    }

    res.json({
      success: true,
      site: {
        id: site.id,
        name: site.name,
        content: site.content,
        createdAt: site.createdAt,
        published: site.published
      }
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

/**
 * PUT /api/voice/site/:id/publish
 * Publication d'un site
 */
app.put('/api/voice/site/:id/publish', async (req, res) => {
  try {
    const { domain } = req.body;

    const site = await prisma.site.update({
      where: { id: req.params.id },
      data: {
        published: true,
        domain: domain || null,
        updatedAt: new Date()
      }
    });

    // TODO: DÃ©ploiement sur edge (Vercel/Netlify/Cloudflare)
    
    res.json({
      success: true,
      message: 'Site published successfully',
      url: domain ? `https://${domain}` : `https://nexus.cloud/s/${site.id}`
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============================================================
// HEALTH CHECK
// ============================================================

app.get('/api/health', (req, res) => {
  res.json({
    status: 'healthy',
    services: {
      whisper: !!process.env.OPENAI_API_KEY,
      claude: !!process.env.ANTHROPIC_API_KEY,
      database: prisma ? 'connected' : 'disconnected'
    },
    timestamp: new Date().toISOString()
  });
});

// ============================================================
// SERVER START
// ============================================================

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`\nðŸš€ Voice Builder Backend running on port ${PORT}`);
  console.log(`ðŸ“¡ Whisper API: ${process.env.OPENAI_API_KEY ? 'Connected' : 'Missing key'}`);
  console.log(`ðŸ¤– Claude API: ${process.env.ANTHROPIC_API_KEY ? 'Connected' : 'Missing key'}`);
  console.log(`ðŸ’¾ Database: Ready\n`);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing server...');
  await prisma.$disconnect();
  process.exit(0);
});

// ============================================================
// EXEMPLE D'UTILISATION (CLIENT)
// ============================================================

/*
// Frontend - Enregistrement et upload audio

const recordAudio = async () => {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const mediaRecorder = new MediaRecorder(stream);
  const chunks = [];

  mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
  
  mediaRecorder.onstop = async () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    const formData = new FormData();
    formData.append('audio', blob, 'recording.webm');
    formData.append('userId', currentUser.id);

    const response = await fetch('http://localhost:5000/api/voice/upload', {
      method: 'POST',
      body: formData
    });

    const { transcription } = await response.json();
    
    // GÃ©nÃ©ration du site
    const siteResponse = await fetch('http://localhost:5000/api/voice/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        transcript: transcription,
        userId: currentUser.id
      })
    });

    const { site, siteId } = await siteResponse.json();
    console.log('Site gÃ©nÃ©rÃ©:', site);
  };

  mediaRecorder.start();
  setTimeout(() => mediaRecorder.stop(), 5000); // 5 secondes
};
*/

export default app;